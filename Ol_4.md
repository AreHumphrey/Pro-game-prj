
# Непростые разбиения

## Условие задачи

Рассмотрим разбиения целого положительного числа \( n \) в сумму целых положительных чисел. Будем называть разбиение **непростым**, если слагаемые в нем:
- Упорядочены по неубыванию.
- Не содержат простых чисел.

### Пример:

Для \( n = 5 \) существует два непростых разбиения:
- \( 1 + 1 + 1 + 1 + 1 \)
- \( 1 + 4 \)

На вход подается число \( n \), где \( 1 < n < 70 \). 

### Формат ввода:
- Одно целое число \( n \).

### Формат вывода:
- Все непростые разбиения \( n \) на слагаемые. 
- Слагаемые разделяются знаком «+». Разбиения можно выводить в любом порядке.

---

## Код решения

```python
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True


def generate_non_prime_partitions(n, current=[], last=1):

    if n == 0:
        print("+".join(map(str, current)))
        return

    for i in range(last, n + 1):
        if not is_prime(i):  # Проверяем, чтобы число не было простым
            generate_non_prime_partitions(n - i, current + [i], i)


if __name__ == "__main__":
    # Ввод числа n
    n = int(input("Введите число n: "))

    generate_non_prime_partitions(n)
```

---

## Объяснение кода

### Функция `is_prime(num)`
Эта функция проверяет, является ли число простым:
- Простое число — это число больше 1, которое делится только на 1 и само на себя.
- Мы используем оптимизацию, проверяя делители только до \( \sqrt{num} \).

### Функция `generate_non_prime_partitions(n, current=[], last=1)`
Эта функция рекурсивно генерирует все разбиения числа \( n \):
- `current` — список текущих слагаемых.
- `last` — последнее добавленное число (это нужно для упорядоченности по неубыванию).

#### Логика:
1. Если \( n = 0 \), то мы нашли одно из разбиений. Его можно вывести.
2. Для всех чисел от `last` до \( n \):
   - Проверяем, чтобы число не было простым (`not is_prime(i)`).
   - Рекурсивно вызываем функцию для оставшейся суммы \( n - i \), добавляя \( i \) в разбиение.

### Пример работы:

#### Ввод:
```
n = 5
```

#### Шаги:
1. Текущее число: 1.
2. Оставшаяся сумма: \( 5 - 1 = 4 \).
3. Следующее слагаемое: 1.
4. Повторяем, пока сумма \( n \) не будет равна 0.

#### Вывод:
```
1+1+1+1+1
1+4
```

---

## Похожие задачи

1. **Разбиение числа с ограничениями**
   - Задача: Разбить число \( n \) на сумму слагаемых, где каждое слагаемое делится на 2 или 3.
   - Пример:
     ```
     Ввод: n = 6
     Вывод: 
     2+2+2
     3+3
     ```

2. **Количество разбиений числа**
   - Задача: Найти количество всех возможных разбиений числа \( n \) на сумму слагаемых (без ограничений).
   - Пример:
     ```
     Ввод: n = 4
     Вывод: 
     Количество разбиений: 5
     ```

3. **Минимальное количество слагаемых**
   - Задача: Разбить число \( n \) на сумму квадратов чисел с минимальным количеством слагаемых.
   - Пример:
     ```
     Ввод: n = 12
     Вывод: 
     4+4+4
     ```

4. **Палиндромные разбиения строки**
   - Задача: Разбить строку на палиндромные подстроки.
   - Пример:
     ```
     Ввод: "aab"
     Вывод: 
     a+a+b
     aa+b
     ``` 

Эти задачи помогут лучше понять динамическое программирование и использование рекурсии.
