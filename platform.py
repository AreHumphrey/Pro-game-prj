# Импортируем необходимые модули
import pygame
import random
import sys

# Инициализируем Pygame — обязательный шаг перед использованием библиотеки
pygame.init()

# Определяем константы (фиксированные значения), чтобы не писать цифры в коде
WIDTH, HEIGHT = 600, 400                  # Ширина и высота окна игры
PLATFORM_WIDTH, PLATFORM_HEIGHT = 100, 15  # Размеры платформы (игрока)
BALL_SIZE = 20                            # Диаметр мячика
PLATFORM_SPEED = 8                        # Скорость движения платформы (пикселей за кадр)
BALL_SPEED = 5                            # Начальная скорость мяча по осям (в пикселях)

# Цвета в формате RGB (Red, Green, Blue) — от 0 до 255
WHITE = (255, 255, 255)   # Белый цвет для текста
BLACK = (0, 0, 0)         # Чёрный цвет для фона
BLUE = (0, 100, 255)      # Синий цвет для платформы
RED = (255, 50, 50)       # Красный цвет для мячика

# Создаём окно игры с заданными размерами
screen = pygame.display.set_mode((WIDTH, HEIGHT))
# Устанавливаем заголовок окна
pygame.display.set_caption("Лови шарик! — Мяч отскакивает от всех стен")

# Создаём прямоугольник для платформы:
# x: по центру по горизонтали (ширина_экрана / 2 - половина ширины платформы)
# y: почти внизу экрана (высота_экрана - 30 пикселей)
# ширина и высота берутся из констант
platform = pygame.Rect(WIDTH // 2 - PLATFORM_WIDTH // 2, HEIGHT - 30, PLATFORM_WIDTH, PLATFORM_HEIGHT)

# Создаём прямоугольник для мячика:
# x: случайное положение по горизонтали (чтобы начать с разного места)
# y: начинается сверху (y = 0)
# ширина и высота — одинаковые, потому что мяч круглый
ball = pygame.Rect(random.randint(0, WIDTH - BALL_SIZE), 0, BALL_SIZE, BALL_SIZE)

# Скорости движения мяча по осям X и Y
# ball_speed_x: случайно выбирается направление — влево (-5) или вправо (+5)
# ball_speed_y: начинается со скоростью +5 (вниз)
ball_speed_x = random.choice([-BALL_SPEED, BALL_SPEED])
ball_speed_y = BALL_SPEED

# Счётчик очков игрока
score = 0

# Создаём шрифт для отображения текста на экране
font = pygame.font.SysFont('Arial', 24)  # Шрифт Arial, размер 24

# Основной игровой цикл
# Переменная running будет False только при выходе из игры
clock = pygame.time.Clock()  # Таймер для контроля FPS
running = True

while running:
    # Обработка событий (например, закрытие окна, нажатие клавиш)
    for event in pygame.event.get():
        # Если пользователь нажал на "крестик" окна
        if event.type == pygame.QUIT:
            running = False  # Выходим из цикла

    # Получаем состояние всех клавиш — можно ли читать нажатия в реальном времени
    keys = pygame.key.get_pressed()

    # Управление платформой стрелками ← и →
    # При нажатии на стрелку влево И если левый край платформы ещё не упирается в границу экрана
    if keys[pygame.K_LEFT] and platform.left > 0:
        platform.x -= PLATFORM_SPEED  # Двигаем платформу влево

    # При нажатии на стрелку вправо И если правый край платформы не выходит за экран
    if keys[pygame.K_RIGHT] and platform.right < WIDTH:
        platform.x += PLATFORM_SPEED  # Двигаем платформу вправо

    # ДВИЖЕНИЕ МЯЧА: обновляем его положение на основе текущих скоростей
    ball.x += ball_speed_x  # Двигаем мяч по горизонтали
    ball.y += ball_speed_y  # Двигаем мяч по вертикали

    # ПРОВЕРКА СТОЛКНОВЕНИЙ СО СТЕНАМИ

    # 1. Столкновение с ЛЕВОЙ стенкой (x <= 0)
    if ball.left <= 0:
        ball_speed_x = -ball_speed_x  # Меняем направление по X на противоположное (влево → вправо)

    # 2. Столкновение с ПРАВОЙ стенкой (x + ширина >= ширина экрана)
    if ball.right >= WIDTH:
        ball_speed_x = -ball_speed_x  # Отскакиваем обратно внутрь экрана

    # 3. Столкновение с ВЕРХНЕЙ стенкой (верх мяча <= 0)
    if ball.top <= 0:
        ball_speed_y = -ball_speed_y  # Меняем направление по Y — отскакиваем вниз

    # 4. Столкновение с НИЖНЕЙ границей (мяч ушёл ниже экрана)
    if ball.top > HEIGHT:
        # Игрок пропустил мяч — штраф: минус одно очко
        score -= 1

        # Перезапускаем мяч сверху:
        ball.x = random.randint(0, WIDTH - BALL_SIZE)  # Новое случайное положение по X
        ball.y = 0  # Начинаем сверху

        # Сбрасываем скорости
        ball_speed_x = random.choice([-BALL_SPEED, BALL_SPEED])  # Новое случайное направление по X
        ball_speed_y = BALL_SPEED  # Начинаем снова двигаться вниз

    # ПРОВЕРКА СТОЛКНОВЕНИЯ С ПЛАТФОРМОЙ
    # Только если мяч движется ВНИЗ (чтобы не было двойного отскока при застревании)
    if ball.colliderect(platform) and ball_speed_y > 0:
        # Отскакиваем вверх
        ball_speed_y = -ball_speed_y  # Изменяем направление движения по Y

        # За успешный отскок добавляем одно очко
        score += 1

        # (Необязательно) Можно немного изменить направление по X в зависимости от того,
        # где именно по платформе ударился мяч — но пока оставим просто отскок

    # ОТРИСОВКА ВСЕГО НА ЭКРАНЕ

    # Заполняем фон чёрным цветом (очищаем предыдущий кадр)
    screen.fill(BLACK)

    # Рисуем платформу как синий прямоугольник
    pygame.draw.rect(screen, BLUE, platform)

    # Рисуем мяч как красный круг
    # ball.center — центр прямоугольника мяча
    # BALL_SIZE // 2 — радиус круга (половина диаметра)
    pygame.draw.circle(screen, RED, ball.center, BALL_SIZE // 2)

    # Создаём текст с текущим счётом
    score_text = font.render(f"Счёт: {score}", True, WHITE)
    # Выводим текст в верхний левый угол (с отступом 10 пикселей)
    screen.blit(score_text, (10, 10))

    # Обновляем экран — показываем всё, что мы нарисовали
    pygame.display.flip()

    # Ограничиваем игру 60 кадрами в секунду (чтобы была плавной и одинаковой на всех ПК)
    clock.tick(60)

# Когда цикл закончился — корректно завершаем Pygame и программу
pygame.quit()
sys.exit()
